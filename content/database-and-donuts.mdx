---
title: 'Database and donuts'
author: 'Vinay Kulkarni'
publishedAt: '2023-09-02'
blog_count: '9'
---

### Hello Thereüêº

Let's talk Database management.

---

<Callout>
  In this blog we will talk about Basics and advanced concepts related to
  **database management** and **SQL**.
</Callout>

<br />
<br />

## ![Database](/content/DBMS/database.svg)

We have a lot of things in DBMS. we are going to cover few important ones here.

- [Cardinallity and it's ratio](#cardinallity-and-it's-ratio)
- [Keys](#keys)
- [Joins](#joins)
- [Functional dependency](#functional-dependency)
- [SQL](#sql)

<br />

### Cardinallity and it's ratio

- **Cardinallity** is a measure to represt how the entities are related to each other.
- There are 4 types of cardinality ratio:
  1. One-to-One
  2. One-to-Many
  3. Many-to-One
  4. Many-to-Many

<br />

### Keys

- Keys play an important role in Database.
- There are various keys:

<div className="flex flex-row gap-x-20">
<div>

1. [Super key](#super-key)
2. [Candidate key](#candidate-key)
3. [Primary key](#primary-key)
4. [Unique key](#unique-key)
5. [Foreign key](#foreign-key)

</div>
   <div className='h-80 w-80'>![Keys in DBMS](/content/DBMS/keys.svg)</div>   
   </div>

#### Super key

- All possible key combinations in a table or a realtion are known as super keys.
- It's like a superset of all keys.

#### Candidate key

- It is a subset of all minimal super keys.
- All **candidate keys** as **super keys**.

#### Primary key

- Subset of candidate keys who's value can not be null.
- A unique attribute in a table which can be used to identify all other keys in the table.
- All primary keys are **Candidate keys**.
- The value can not be null.

#### Unique key

- Subset of **Candidate keys** which are not **primary key**
- Value can be null.

#### Foreign key

- The attribute from one table which is refferenced in other table.
- It can only take values which are defined in the parent table.
- A foreign key is allways reffering a primary key of other table.

<br />

### Prime and Non-Prime attributes

| Prime attributes                                  | Non Prime attributes                                      |
| ------------------------------------------------- | --------------------------------------------------------- |
| The attributes which are part of a candidate key. | The attributes which are **not** part of a candidate key. |
| Say Candidate Key is `AB-->CD`.                   | Say Candidate Key is `AB-->CD`.                           |
| `AB` are Prime attributes.                        | `CD` are Non Prime attributes.                            |

<br />

### Partial dependency

- For a Candidate key `AB-->CD` if there exists a relation `B-->C` or `B-->D` or `A-->C` or `A-->D` then this is called partial dependency.
- Basically all **non prime attributes** should completely depend only on **Candidate key**.

<br />

### Transitive dependency

- For a given candidate key `A-->BC` we have realtions `B-->C`.
- `A` is **prime attribute**.
- `B` and `C` are **non prime attributes**.
- `B` being a non prime attribute is identifying `C` which is also a non prime attribute.
- This kind of situation in **Transitive dependency**.

<br />

### Joins

- Joining one or more tables together on some common attribute or some comparison of columns from both the tables.
- There are multiple types of join:
  1. [Natural Join](#natural-join)
  2. [Equi Join](#equi-join)
  3. [Self Join](#self-join)
  4. Outter Join:
     - [Left outter join](#left-outter-join)
     - [Right outter join](#right-outter-join)
     - [Full outter join](#full-outter-join)

#### Natural Join

- Joining two tables based on the common attributes which is in both the tables.

#### Equi Join

- It is same of [natural join](#natural-join) but here you can join the tables based on any attribute.
- The joining attribute need not be the same.

#### Self Join

- Here we join the table with itself.

#### Left outter Join

- After joining two tables we get the common attributes from both the table along with that we get all the attributes from **left** table.
- Syntax:`SELECT * FROM emp LEFT OUTTER JOIN(dept) ON(emp.id = dept.id)`

#### Right outter Join

- After joining two tables we get the common attributes from both the table along with that we get all the attributes from **right** table.
- Syntax:`SELECT * FROM emp RIGHT OUTTER JOIN(dept) ON(emp.id = dept.id)`

#### FULL outter Join

- After joining two tables we get the common attributes from both the table along with that we get all the attributes from **BOTH** tables.
- Syntax:`SELECT * FROM emp FULL OUTTER JOIN(dept) ON(emp.id = dept.id)`

<br />

### Functional dependency

- A given attribute relation `X-->Y`. Here `Y` is said to be dependent on `X`.
- If `X` can uniquely identify `Y` for any value of `X`.

| Trivial Functional dependency | Non-Trivial Functional dependency |
| ----------------------------- | --------------------------------- |
| `X-->Y`                       | `X-->Y`                           |
| <code>Y &#x2286; X</code>     | <code>Y &#x2288; X</code>         |
| EX: `AB-->A`                  | EX: `AB-->C`                      |

<br />

### Closure set

- It is a set of all attribute which can be identied by a given attribute.
- <code>
    (A)<sup>+</sup>=ABC
  </code>

<br />

### Normalization

- Breaking down a bigger table into smaller tables based on some rules is **normalization**.
- Need for **normalization** is to get rid of problem realted with **INSERT**, **UPDATE** and **DELETE** anomalies.
- Or in simple terms u can say that you want to get rid of redundancy.
- Various normalization forms:
  1. [1NF](#1nf)
  2. [2NF](#2nf)
  3. [3NF](#3nf)
  4. [BCNF](#bcnf)
  5. [4NF](#4nf)

#### 1NF

- Each cell in a table should have only atomic or one value.
- Or you can say that each cell should not have multivalued attribute.
- How to convert a table into 1NF if it is not in 1NF form:
  - Make one more row for each multivalued attribute in a cell.

#### 2NF

- We need to know the concept of [Prime and Non-Prime attributes](#prime-and-non-prime-attributes) to understand 2NF.
- Consider Candidate keys `AB-->CD`, `B-->C` and `AB-->D`.
- Here `CD` are **Non Prime attributes** and `AB` are **Prime attributes**.
- `C` is entirely not dependent on the **prime attributes** or **candidate keys**.
- `C` can be derived from a subset of **Prime attribute** `B`.
- This is known as **[Partial dependency](#partial-dependency)**.
- **Partial dependency** is to be avoided in **2NF**.
- In simple terms we can say that **non prime attributes** should entirely depend on **candidate key** and not a **subset** of the **candidate key**.
- How to make a table into **2NF**:
  - Make another table with **candidate key** and all the attributes which are completely dependent on the candidate key.
  - Make separate table for all the other keys which are defying the rule of partial dependency.

<br />

#### 3NF

- We Need to avoid [Transitive dependency](#transitive-dependency).
- For any given functional dependency `X--->Y` If we satisfy **either** of the two rules then the table is in 3NF
  1. `X` should be a **super key**.
  2. `Y` should be a **Prime attribute**.
- How to make table into 3NF:
- Whoever is voilating the rule make separate table for them along with all the attributes which it is identifying.

<br />

#### BCNF

- Only one condition is there:
- **LHS** should be a [Super key](#super-key).

<br />

### SQL

- Structured Query Language.
- Used to talk with the database.
- Multiple types of commands are there in SQL, Mainly
  1. DDL (Data Definition Language)
  2. DML (Data Manipulation Language)
  3. DCL (Data Control Language)
  4. TCL (Transaction Control Language)

| DDL                                                                                                 | DML                                                                                  | DCL                                                                                             | TCL                                                                               |
| --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| Commands which are used to defines the data. Like **TABLES**, **DATABASE**, **VIEWS**, **TRIGGERS** | Commands which are used to Manipulate the existing data. Like **UPDATE**, **INSERT** | Commands which are used to control the behaviour or charecteristics of the data. Like **GRANT** | Commands which are used to control transactions in the database. Like **COMMMIT** |
| **CREATE**                                                                                          | **INSERT**                                                                           | **GRANT**                                                                                       | **COMMIT**                                                                        |
| **DROP**                                                                                            | **UPDATE**                                                                           | **REVOKE**                                                                                      | --                                                                                |
| **ALTER**                                                                                           | **DELETE**                                                                           | --                                                                                              | --                                                                                |

<br />
<br />

**Good Day üêº**
